import { useContext } from "react";
import { getLanguageNamesFromCode, ILanguage } from "./Language";
import { useContentful } from "react-contentful";
import { CachedTablesContext } from "../App";
import { ICollection } from "./ContentInterfaces";
import { convertContentfulCollectionToICollection } from "./Contentful";
import { kTopicList } from "./ClosedVocabularies";
import { IFilter } from "../IFilter";

/* From original design: Each collection has
    id
    label
    child collections [ 0  or more ] (potentially ordered?)
    book query (optional)
    pageType (optional)
    banner specification (optional)
    card icon (optional)
    A (potentially ordered) set of books ←- this comes from Parse, not Contentful

    Banner
        ID
        Background Image (optional) We use the “card icon” if this is missing (e.g. all publishers)
        Image Credits
        Blurb
*/

// If we don't find a contentful collection for language:xx, we create one.
export function makeLanguageCollection(
    templateCollection: ICollection,
    langCode: string,
    languages: ILanguage[]
): ICollection {
    let languageDisplayName = getLanguageNamesFromCode(langCode!, languages)
        ?.displayNameWithAutonym;
    if (!languageDisplayName) languageDisplayName = langCode;
    return {
        ...templateCollection,
        urlKey: "language:" + langCode,
        label: languageDisplayName,
        childCollections: [],
        filter: { language: langCode },
    };
}

export function makeTopicCollection(
    templateCollection: ICollection,
    topicName: string
): ICollection {
    return {
        ...templateCollection,
        urlKey: "topic:" + topicName,
        label: topicName,
        childCollections: [],
        filter: { topic: topicName },
    };
}

export function makeCollectionForSearch(
    templateCollection: ICollection,
    search: string,
    baseCollection?: ICollection
): ICollection {
    const filter = { ...baseCollection?.filter, search };
    let label = 'Books matching "' + decodeURIComponent(search) + '"';
    if (baseCollection?.label) {
        label = baseCollection.label + " - " + label;
    }
    let urlKey = "search:" + search;
    if (baseCollection?.urlKey) {
        urlKey = baseCollection.urlKey + "/" + urlKey;
    }
    // Enhance: how can we modify title to indicate that it's restricted to books matching a search,
    // given that it's some unknown contentful representation of a rich text?
    const result: ICollection = {
        ...templateCollection,
        ...baseCollection,
        filter,
        label,
        urlKey,
        childCollections: [],
    };
    return result;
}

export function makeCollectionForPHash(
    templateCollection: ICollection,
    phash: string
): ICollection {
    // review: would it be cleaner to make phash a top-level field in filter?
    // Would require changes to the LibraryQueryHooks function for interpreting
    // filter. It's also remotely possible that losing the ability to type
    // a phash: into the search box would be missed.
    const filter = { search: "phash:" + phash };
    const urlKey = "phash:" + phash;
    const result: ICollection = {
        ...templateCollection,
        filter,
        urlKey,
        childCollections: [],
    };
    return result;
}

export function getDummyCollectionForPreview(bannerId: string): ICollection {
    return {
        label: "dummy",
        urlKey: "dummy",
        filter: {},
        childCollections: [],
        bannerId,
        iconForCardAndDefaultBanner: undefined,
        layout: "by-level",
    };
}
function makeTopicSubcollections(): ICollection[] {
    return kTopicList.map((t) =>
        makeTopicCollection(
            {
                urlKey: "topic:" + t,
                label: t,
                childCollections: [],
                filter: { topic: t },
                bannerId: "",
                layout: "by-level",
            },
            t
        )
    );
}

interface IContentfulCollectionQueryResponse {
    collection?: ICollection;
    error?: object; // whatever useContentful gives us if something goes wrong.
    loading: boolean; // Hook response loading || !fetched, that is, we don't actually have a result yet
}

// A hook function for working with collections, generally retrieved from contentful.
// Usually when first called it will return a result with loading true and the collection undefined.
// When the query is complete a state change will cause it to be called again and return a useful
// result.
// In some cases, if a collection is not found on contentful, it is generated by code here.
export function useGetCollection(
    collectionName: string
): IContentfulCollectionQueryResponse {
    const { languagesByBookCount: languages } = useContext(CachedTablesContext);

    // We have template collections for everything, and then also we can provide
    // override collections for any value. E.g. our query will first look for a
    // collection named "Language:en", but then if that is not found, it will
    // return "[Template Language Collection]".
    const nameParts = collectionName.split(":");
    let templateKey = "Don't match anything";
    if (nameParts.length > 1) {
        templateKey = `[Template ${Capitalize(nameParts[0])} Collection]`;
    }

    const { data, error, fetched, loading } = useContentful({
        contentType: "collection",
        query: {
            "fields.urlKey[in]": `${collectionName},${templateKey}`,
        },
    });
    if (loading || !fetched) {
        return { collection: undefined, loading: true };
    }

    if (error) {
        console.error(error);
        return { collection: undefined, error, loading: false };
    }

    if (!data || (data as any).items.length === 0) {
        return { loading: false };
    }

    // Note that for things like topic, keyword, and search, this is the *template* collection, which
    // we'll use later to create the actual collection.
    let collection = convertContentfulCollectionToICollection(
        (data as any).items[0].fields
    );

    if (nameParts.length > 1) {
        const value = nameParts[1];
        switch (nameParts[0]) {
            case "language":
                // language collections are optionally generated. We can make real cards if we
                // want, to give a more interesting background image etc, but if we don't have
                // one for a language, we generate a default here.
                // We currently don't need to mess with the actual content of the languages
                // collection because a special case in CollectionPage for the language-chooser urlKey
                // creates a special LanguageGroup row, which determines the children directly
                // from the main database.
                collection = makeLanguageCollection(
                    collection,
                    value,
                    languages
                );
                return { collection, loading: false };

            case "topic":
                // topic collections currently are generated from the fixed list above.
                // the master "topics" collection is real (so it can be included at the
                // right place in its parent) but its children are inserted by another special case.
                collection = makeTopicCollection(collection, value);
                return { collection, loading: false };

            case "keyword":
                collection = makeCollectionForKeyword(collection, value);
                return { collection, loading: false };

            case "search":
                // search collections are generated from a search string the user typed.
                collection = makeCollectionForSearch(collection, value);
                return { collection, loading: false };

            case "phash":
                // search collections are generated from a search string the user typed.
                collection = makeCollectionForPHash(collection, value);
                return { collection, loading: false };

            default:
                return { loading: false };
        }
    } else {
        // usual case, got collection from contentful

        if (collection.urlKey === "topics") {
            // We currently generate the one collection for each topic, just
            // for showing the cards. If someone clicks a card, well then we
            // go and see what the collection should really be. If we ever
            // want to use icons on the card, then we can just remove this
            // whole block and instead populate the "Topics" collection on
            // Contentful
            collection.childCollections = makeTopicSubcollections();
        }
        return { collection, loading: false };
    }
}

export function makeCollectionForKeyword(
    templateCollection: ICollection,
    keyword: string,
    baseCollection?: ICollection
): ICollection {
    const filter: IFilter = {
        ...baseCollection?.filter,
        keywordsText: keyword,
    };
    let label = "Books with keyword " + keyword;
    if (baseCollection?.label) {
        label = baseCollection.label + " - " + label;
    }

    let urlKey = "keyword:" + keyword;
    if (baseCollection?.urlKey) {
        urlKey = baseCollection.urlKey + "/" + urlKey;
    }
    // Enhance: how can we append "- keyword" to title, given that it's some unknown
    // contentful representation of a rich text?
    return {
        ...templateCollection,
        ...baseCollection,
        filter,
        label,
        urlKey,
        childCollections: [],
        iconForCardAndDefaultBanner: undefined,
    };
}
function Capitalize(s: string): string {
    return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
}
